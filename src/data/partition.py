from __future__ import annotations

import json
import os
from typing import List, Sequence

import numpy as np


def dirichlet_partition(
    labels: Sequence[int], n_clients: int, beta: float, seed: int, min_size: int = 1
) -> List[List[int]]:
    """Partition sample indices across clients via a Dirichlet distribution.

    Each class is split independently according to a Dirichlet distribution
    with concentration parameter ``beta``.  The process is repeated until
    every client receives at least ``min_size`` examples in total.

    Args:
        labels: Array‑like sequence of integer class labels.
        n_clients: Number of clients to generate.
        beta: Dirichlet distribution concentration parameter.  Smaller
            values yield more skewed (non‑IID) splits.
        seed: Random seed for reproducibility.
        min_size: Minimum number of samples required per client.

    Returns:
        A list of length ``n_clients`` where each element contains the
        sample indices assigned to that client.
    """
    rng = np.random.RandomState(seed)
    labels = np.array(labels)
    n_classes = int(labels.max()) + 1
    indices_per_class = [np.where(labels == c)[0] for c in range(n_classes)]

    attempt = 0
    while True:
        client_indices: List[List[int]] = [[] for _ in range(n_clients)]
        for c, idxs in enumerate(indices_per_class):
            rng.shuffle(idxs)
            proportions = rng.dirichlet([beta] * n_clients)
            counts = (proportions * len(idxs)).astype(int)
            diff = len(idxs) - counts.sum()
            for i in range(diff):
                counts[i % n_clients] += 1
            start = 0
            for client_id in range(n_clients):
                count = counts[client_id]
                client_indices[client_id].extend(idxs[start : start + count].tolist())
                start += count
        sizes = [len(idxs) for idxs in client_indices]
        if min(sizes) >= min_size:
            break
        attempt += 1
        if attempt > 10:
            min_size = max(1, min_size // 2)
    return client_indices


def save_partition_manifest(
    client_indices: List[List[int]], out_path: str, dataset_name: str, seed: int, beta: float
) -> None:
    """Save a JSON manifest of the partition for reproducibility.

    Args:
        client_indices: A list of index lists generated by :func:`dirichlet_partition`.
        out_path: Path to write the JSON file.
        dataset_name: Name of the dataset (e.g. ``cifar10``).
        seed: Random seed used for partitioning.
        beta: Dirichlet concentration parameter.
    """
    manifest = {
        "dataset": dataset_name,
        "seed": seed,
        "beta": beta,
        "n_clients": len(client_indices),
        "partitions": {str(i): idxs for i, idxs in enumerate(client_indices)},
    }
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(manifest, f, indent=2)
